package phaserHaxe.cameras.scene2D.effects;

import js.html.CanvasRenderingContext2D;
import phaserHaxe.math.MathUtility;
import phaserHaxe.cameras.scene2D.typedefs.CameraFlashCallback;

/**
 * A Camera Flash effect.
 *
 * This effect will flash the camera viewport to the given color, over the duration specified.
 *
 * Only the camera viewport is flashed. None of the objects it is displaying are impacted, i.e. their colors do
 * not change.
 *
 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
 * which is invoked each frame for the duration of the effect, if required.
 *
 * @since 1.0.0
**/
class Flash
{
	/**
	 * The Camera this effect belongs to.
	 *
	 * @since 1.0.0
	**/
	public var camera(default, null):Camera;

	/**
	 * Is this effect actively running?
	 *
	 * @since 1.0.0
	**/
	public var isRunning(default, null):Bool = false;

	/**
	 * The duration of the effect, in milliseconds.
	 *
	 * @since 1.0.0
	**/
	public var duration(default, null):Int = 0;

	/**
	 * The value of the red color channel the camera will use for the fade effect.
	 * A value between 0 and 255.
	 *
	 * @since 1.0.0
	**/
	private var red:Int = 0;

	/**
	 * The value of the green color channel the camera will use for the fade effect.
	 * A value between 0 and 255.
	 *
	 * @since 1.0.0
	**/
	private var green:Int = 0;

	/**
	 * The value of the blue color channel the camera will use for the fade effect.
	 * A value between 0 and 255.
	 *
	 * @since 1.0.0
	**/
	private var blue:Int = 0;

	/**
	 * The value of the alpha channel used during the fade effect.
	 * A value between 0 and 1.
	 *
	 * @since 1.0.0
	**/
	private var alpha:Float = 0;

	/**
	 * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
	 *
	 * @since 1.0.0
	**/
	public var progress:Float = 0;

	/**
	 * Effect elapsed timer.
	 *
	 * @since 1.0.0
	**/
	private var _elapsed:Float = 0;

	/**
	 * This callback is invoked every frame for the duration of the effect.
	 *
	 * @since 1.0.0
	**/
	private var _onUpdate:CameraFlashCallback = null;

	/**
	 * On Complete callback scope.
	 *
	 * @since 1.0.0
	**/
	private var _onUpdateScope:Any = null;

	public function new(camera:Camera)
	{
		this.camera = camera;
	}

	/**
	 * Flashes the Camera to or from the given color over the duration specified.
	 *
	 * @method Phaser.Cameras.Scene2D.Effects.Flash#start
	 * @fires Phaser.Cameras.Scene2D.Events#FLASH_START
	 * @fires Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE
	 * @since 3.5.0
	 *
	 * @param duration - The duration of the effect in milliseconds.
	 * @param red - The amount to fade the red channel towards. A value between 0 and 255.
	 * @param green - The amount to fade the green channel towards. A value between 0 and 255.
	 * @param blue - The amount to fade the blue channel towards. A value between 0 and 255.
	 * @param force - Force the effect to start immediately, even if already running.
	 * @param callback - This callback will be invoked every frame for the duration of the effect.
	 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
	 * @param context - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
	 *
	 * @return The Camera on which the effect was started.
	**/
	public function start(duration:Int = 250, red:Int = 255, green:Int = 255,
			blue:Int = 255, force:Bool = false, ?callback:CameraFlashCallback,
			?context:Any):Camera
	{
		if (!force && isRunning)
		{
			return camera;
		}

		isRunning = true;
		this.duration = duration;
		progress = 0;

		this.red = red;
		this.green = green;
		this.blue = blue;
		this.alpha = 1;

		_elapsed = 0;

		_onUpdate = callback;
		_onUpdateScope = context;

		camera.emit(Events.FLASH_START, [camera, this, duration, red, green, blue]);

		return camera;
	}

	/**
	 * The main update loop for this effect. Called automatically by the Camera.
	 *
	 * @since 1.0.0
	 *
	 * @param time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
	 * @param delta - The delta time, in ms, elapsed since the last frame.
	**/
	public function update(time:Int, delta:Float):Void
	{
		if (!isRunning)
		{
			return;
		}

		_elapsed += delta;

		progress = MathUtility.clamp(_elapsed / duration, 0, 1);

		if (_onUpdate != null)
		{
			callUpdate(_onUpdateScope, camera, progress);
		}

		if (_elapsed < duration)
		{
			alpha = 1 - progress;
		}
		else
		{
			effectComplete();
		}
	}

	/**
	 * Called internally by the Canvas Renderer.
	 *
	 * @since 1.0.0
	 *
	 * @param ctx - The Canvas context to render to.
	 *
	 * @return `true` if the effect drew to the renderer, otherwise `false`.
	**/
	public function postRenderCanvas(ctx:CanvasRenderingContext2D):Bool
	{
		if (!isRunning)
		{
			return false;
		}

		var camera = this.camera;

		ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + alpha + ')';
		ctx.fillRect(camera._cx, camera._cy, camera._cw, camera._ch);

		return true;
	}

	/**
	 * Called internally by the WebGL Renderer.
	 *
	 * @since 1.0.0
	 *
	 * @param {Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline} pipeline - The WebGL Pipeline to render to.
	 * @param {function} getTintFunction - A function that will return the gl safe tint colors.
	 *
	 * @return `true` if the effect drew to the renderer, otherwise `false`.
	**/
	// TODO: do when WebGL ready
	public function postRenderWebGL(pipeline:Dynamic, getTintFunction:Dynamic):Bool
	{
		if (!isRunning)
		{
			return false;
		}

		var red = this.red / 255;
		var blue = this.blue / 255;
		var green = this.green / 255;

		pipeline.drawFillRect(camera._cx, camera._cy, camera._cw, camera._ch, getTintFunction(red, green, blue, 1), alpha);

		return true;
	}

	/**
	 * Called internally when the effect completes.
	 *
	 * @fires Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE
	 * @since 3.5.0
	**/
	public function effectComplete()
	{
		_onUpdate = null;
		_onUpdateScope = null;

		isRunning = false;

		camera.emit(Events.FLASH_COMPLETE, [camera, this]);
	}

	/**
	 * Resets this camera effect.
	 * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
	 *
	 * @since 1.0.0
	**/
	public function reset()
	{
		isRunning = false;

		_onUpdate = null;
		_onUpdateScope = null;
	}

	/**
	 * Destroys this effect, releasing it from the Camera.
	 *
	 * @since 1.0.0
	**/
	public function destroy()
	{
		reset();

		camera = null;
	}

	private inline function callUpdate(context:Any, camera:Camera, progress:Float)
	{
		#if js
		if (_onUpdateScope != null)
		{
			(cast _onUpdate : js.lib.Function).call(context, camera, progress);
		}
		else
		#end
		{
			_onUpdate(camera, progress);
		}
	}
}
