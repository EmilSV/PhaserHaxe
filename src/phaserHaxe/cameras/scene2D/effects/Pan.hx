package phaserHaxe.cameras.scene2D.effects;

import phaserHaxe.math.MathUtility;
import phaserHaxe.math.EaseMap;
import phaserHaxe.math.Easing;
import phaserHaxe.math.Vector2;
import phaserHaxe.utils.types.Union;
import phaserHaxe.cameras.scene2D.typedefs.CameraPanCallback;

/**
 * A Camera Pan effect.
 *
 * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,
 * over the duration and with the ease specified.
 *
 * Only the camera scroll is moved. None of the objects it is displaying are impacted, i.e. their positions do
 * not change.
 *
 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
 * which is invoked each frame for the duration of the effect if required.
 *
 * @since 1.0.0
**/
class Pan
{
	/**
	 * The Camera this effect belongs to.
	 *
	 * @since 1.0.0
	**/
	public var camera(default, null):Camera;

	/**
	 * Is this effect actively running?
	 *
	 * @since 1.0.0
	**/
	public var isRunning(default, null):Bool = false;

	/**
	 * The duration of the effect, in milliseconds.
	 *
	 * @since 1.0.0
	**/
	public var duration(default, null):Float = 0;

	/**
	 * The starting scroll coordinates to pan the camera from.
	 *
	 * @since 1.0.0
	**/
	public var source(default, null):Vector2 = new Vector2();

	/**
	 * The constantly updated value based on zoom.
	 *
	 * @since 1.0.0
	**/
	public var current(default, null):Vector2 = new Vector2();

	/**
	 * The destination scroll coordinates to pan the camera to.
	 *
	 * @since 1.0.0
	**/
	public var destination(default, null):Vector2 = new Vector2();

	/**
	 * The ease function to use during the pan.
	 *
	 * @since 1.0.0
	**/
	public var ease:(Float) -> Float;

	/**
	 * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
	 *
	 * @since 1.0.0
	**/
	public var progress(default, null):Float = 0;

	/**
	 * Effect elapsed timer.
	 *
	 * @since 1.0.0
	**/
	private var _elapsed:Float = 0;

	/**
	 * This callback is invoked every frame for the duration of the effect.
	 *
	 * @since 1.0.0
	**/
	private var _onUpdate:Null<CameraPanCallback> = null;

	/**
	 * On Complete callback scope.
	 *
	 * @since 1.0.0
	**/
	private var _onUpdateScope:Null<Any> = null;

	public function new(camera:Camera)
	{
		this.camera = camera;
	}

	/**
	 * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,
	 * over the duration and with the ease specified.
	 *
	 * @fires Phaser.Cameras.Scene2D.Events#PAN_START
	 * @fires Phaser.Cameras.Scene2D.Events#PAN_COMPLETE
	 * @since 1.0.0
	 *
	 * @param x - The destination x coordinate to scroll the center of the Camera viewport to.
	 * @param y - The destination y coordinate to scroll the center of the Camera viewport to.
	 * @param duration - The duration of the effect in milliseconds.
	 * @param ease - The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function.
	 * @param force - Force the pan effect to start immediately, even if already running.
	 * @param callback - This callback will be invoked every frame for the duration of the effect.
	 * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
	 * the current camera scroll x coordinate and the current camera scroll y coordinate.
	 * @param context - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
	 *
	 * @return The Camera on which the effect was started.
	**/
	public function start(x:Float, y:Float, duration:Float = 1000,
			?ease:Union<String, (Float) -> Float>, force:Bool = false,
			?callback:CameraPanCallback, ?context:Any):Camera
	{
		if (ease == null)
		{
			ease = Easing.linear;
		}

		var cam = this.camera;

		if (!force && this.isRunning)
		{
			return cam;
		}

		this.isRunning = true;
		this.duration = duration;
		this.progress = 0;

		//  Starting from
		this.source.set(cam.scrollX, cam.scrollY);

		//  Destination
		this.destination.set(x, y);

		//  Zoom factored version
		cam.getScroll(x, y, this.current);

		//  Using this ease
		if (Std.is(ease, String) && EaseMap.exists(cast ease))
		{
			this.ease = EaseMap.get(cast ease);
		}
		else if (Reflect.isFunction(ease))
		{
			this.ease = cast ease;
		}

		_elapsed = 0;

		_onUpdate = callback;
		_onUpdateScope = context;

		camera.emit(Events.PAN_START, [camera, this, duration, x, y]);

		return cam;
	}

	/**
	 * The main update loop for this effect. Called automatically by the Camera.
	 *
	 * @since 1.0.0
	 *
	 * @param time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
	 * @param delta - The delta time, in ms, elapsed since the last frame.
	**/
	public function update(time:Int, delta:Float)
	{
		if (!isRunning)
		{
			return;
		}

		_elapsed += delta;

		final progress = MathUtility.clamp(_elapsed / duration, 0, 1);

		this.progress = progress;

		final cam = camera;

		if (_elapsed < duration)
		{
			final v = ease(progress);

			cam.getScroll(destination.x, destination.y, current);

			final x = source.x + ((current.x - source.x) * v);
			final y = source.y + ((current.y - source.y) * v);

			cam.setScroll(x, y);

			if (_onUpdate != null)
			{
				callOnUpdate(_onUpdateScope, cam, progress, x, y);
			}
		}
		else
		{
			cam.centerOn(destination.x, destination.y);

			if (_onUpdate != null)
			{
				callOnUpdate(_onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);
			}

			effectComplete();
		}
	}

	/**
	 * Called internally when the effect completes.
	 *
	 * @fires Phaser.Cameras.Scene2D.Events#PAN_COMPLETE
	 * @since 1.0.0
	**/
	public function effectComplete()
	{
		_onUpdate = null;
		_onUpdateScope = null;

		isRunning = false;

		camera.emit(Events.PAN_COMPLETE, [camera, this]);
	}

	/**
	 * Resets this camera effect.
	 * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
	 *
	 * @since 1.0.0
	**/
	public function reset()
	{
		isRunning = false;

		_onUpdate = null;
		_onUpdateScope = null;
	}

	/**
	 * Destroys this effect, releasing it from the Camera.
	 *
	 * @since 1.0.0
	**/
	public function destroy()
	{
		reset();

		camera = null;
		source = null;
		destination = null;
	}

	private inline function callOnUpdate(context:Any, camera:Camera, progress:Float,
			x:Float, y:Float)
	{
		#if js
		if (_onUpdateScope != null)
		{
			(cast _onUpdate : js.lib.Function).call(context, camera, progress, x, y);
		}
		else
		#end
		{
			_onUpdate(camera, progress, x, y);
		}
	}
}
