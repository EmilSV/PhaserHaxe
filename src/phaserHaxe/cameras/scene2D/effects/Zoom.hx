package phaserHaxe.cameras.scene2D.effects;

import phaserHaxe.math.Easing;
import phaserHaxe.math.easing.EasingLinear;
import js.Syntax;
import phaserHaxe.math.MathUtility;
import phaserHaxe.utils.types.Union;
import haxe.Constraints.Function;
import phaserHaxe.cameras.scene2D.typedefs.CameraZoomCallback;
import phaserHaxe.math.EaseMap;

/**
 * A Camera Zoom effect.
 *
 * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.
 *
 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
 * which is invoked each frame for the duration of the effect if required.
 *
 * @since 1.0.0
 *
**/
class Zoom
{
	/**
	 * The Camera this effect belongs to.
	 *
	 * @since 1.0.0
	**/
	public var camera(default, null):Camera;

	/**
	 * Is this effect actively running?
	 *
	 * @since 1.0.0
	**/
	public var isRunning(default, null) = false;

	/**
	 * The duration of the effect, in milliseconds.
	 *
	 * @since 1.0.0
	**/
	public var duration(default, null) = 0;

	/**
	 * The starting zoom value;
	 *
	 * @since 1.0.0
	**/
	public var source:Float = 1;

	/**
	 * The destination zoom value.
	 *
	 * @since 1.0.0
	**/
	public var destination:Float = 1;

	/**
	 * The ease function to use during the zoom.
	 *
	 * @since 1.0.0
	**/
	public var ease:(Float) -> Float;

	/**
	 * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
	 *
	 * @since 1.0.0
	**/
	public var progress:Float = 0;

	/**
	 * Effect elapsed timer.
	 *
	 * @since 1.0.0
	**/
	private var _elapsed:Float = 0;

	/**
	 * This callback is invoked every frame for the duration of the effect.
	 *
	 * @since 1.0.0
	**/
	private var _onUpdate:CameraZoomCallback = null;

	/**
	 * On Complete callback scope.
	 *
	 * @since 1.0.0
	**/
	private var _onUpdateScope:Any;

	public function new(camera:Camera)
	{
		this.camera = camera;
	}

	private inline function callUpdate(context:Any, camera:Camera, progress:Float,
			zoom:Float)
	{
		#if js
		if (_onUpdateScope != null)
		{
			(cast _onUpdate : js.lib.Function).call(context, camera, progress, zoom);
		}
		else
		#end
		{
			_onUpdate(camera, progress, zoom);
		}
	}

	/**
	 * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.
	 *
	 * @fires Phaser.Cameras.Scene2D.Events#ZOOM_START
	 * @fires Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE
	 * @since 1.0.0
	 *
	 * @param zoom - The target Camera zoom value.
	 * @param duration - The duration of the effect in milliseconds.
	 * @param ease - The ease to use for the Zoom. Can be any of the Phaser Easing constants or a custom function.
	 * @param force - Force the zoom effect to start immediately, even if already running.
	 * @param callback - This callback will be invoked every frame for the duration of the effect.
	 * It is sent three arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,
	 * and the current camera zoom value.
	 * @param context - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
	 *
	 * @return The Camera on which the effect was started.
	**/
	public function start(zoom:Float, duration:Int = 1000,
			?ease:Union<String, (Float) -> Float>, force:Bool = false,
			callback:CameraZoomCallback = null, ?context:Any):Camera
	{
		if (ease == null)
		{
			ease = Easing.linear;
		}

		if (!force && isRunning)
		{
			return camera;
		}

		isRunning = true;
		this.duration = duration;
		progress = 0;

		//  Starting from
		source = camera.zoom;

		//  Zooming to
		destination = zoom;

		//  Using this ease
		if (Std.is(ease, String) && EaseMap.exists(cast ease))
		{
			this.ease = EaseMap.get(cast ease);
		}
		else if (Reflect.isFunction(ease))
		{
			this.ease = cast ease;
		}

		_elapsed = 0;

		_onUpdate = callback;
		_onUpdateScope = context;

		camera.emit(CameraEvents.ZOOM_START, [(camera : Dynamic), (this : Dynamic), (duration : Dynamic), (zoom : Dynamic)]);

		return camera;
	}

	/**
	 * The main update loop for this effect. Called automatically by the Camera.
	 *
	 * @since 1.0.0
	 *
	 * @param time - The current timestamp as generated by the Request Animation Frame or SetTimeout.
	 * @param delta - The delta time, in ms, elapsed since the last frame.
	**/
	public function update(time:Int, delta:Float):Void
	{
		if (!isRunning)
		{
			return;
		}

		_elapsed += delta;

		progress = MathUtility.clamp(_elapsed / duration, 0, 1);

		if (_elapsed < duration)
		{
			camera.zoom = source + ((destination - source) * ease(progress));

			if (_onUpdate != null)
			{
				callUpdate(_onUpdateScope, camera, progress, camera.zoom);
			}
		}
		else
		{
			camera.zoom = destination;

			if (_onUpdate != null)
			{
				callUpdate(_onUpdateScope, camera, progress, destination);
			}

			effectComplete();
		}
	}

	/**
	 * Called internally when the effect completes.
	 *
	 * @fires Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE
	 * @since 1.0.0
	**/
	public function effectComplete()
	{
		_onUpdate = null;
		_onUpdateScope = null;

		isRunning = false;

		camera.emit(CameraEvents.ZOOM_COMPLETE, [camera, this]);
	}

	/**
	 * Resets this camera effect.
	 * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
	 *
	 * @since 1.0.0
	**/
	public function reset()
	{
		isRunning = false;

		_onUpdate = null;
		_onUpdateScope = null;
	}

	/**
	 * Destroys this effect, releasing it from the Camera.
	 *
	 * @since 1.0.0
	**/
	public function destroy()
	{
		reset();
		camera = null;
	}
}
